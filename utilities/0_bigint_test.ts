/**
 * MTKruto - Cross-runtime JavaScript library for building Telegram clients
 * Copyright (C) 2023-2024 Roj <https://roj.im/>
 *
 * This file is part of MTKruto.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import { assert, assertEquals } from "../0_deps.ts";
import { bigIntFromBuffer, getRandomBigInt, getRandomId, mod, modExp } from "./0_bigint.ts";

Deno.test("modExp", () => {
  const cases = [
    [
      [
        25729595741072683897395109189808684797105362035731884977192283959464082548344604028595292234221647685794939572482174505316578473918104854348467618479063576135616012332420362247948399268452256909041394874641466746300761638236339805368550219122595362689377011155319107197390084372129268816010744106764826608921646155673895717859821807311015548491728308015810192531050802879732222315586158825479699529436993191553803120367257786196340242566683721651729017824498387153069407645089241067559634721239760605104981133188165653880829121228035239136570952533702232036095887062441203579541324206660976923886026904819301416358188n,
        6134506n,
        27814179938144654428117944459530900006588588510591328597607247224265067304074035564584254705023066811119556557858522367589694743379138717605103633860525056359770299966918313415492246353944736236774865530194935162332233137272814743004566057213157538712742307074772596138218189271059536492064456168078351299479605526803997035020669588112240030983279746271940284345458668424043823546777567440417260260658952654628105908371277170347096185211629869355187642309440877759914268066708303905603496022954808332467689697960770195240177220665879613349146829860926031693626215827405709658807668957313625712929056345084137341144662n,
      ],
      9803324203068422937675154543704054500531605987090887971842982741710860673895073110973602224251638504057038621374079955124353796938063235363424180407549013847524669750383156852188999511479939087074089079693191821933712767059091431479506415267627135403241858995388604667146478909884974524543407546865771670921452307829865995496189057179125648971724357623900382041813192057677898877624003023661236332643406067921281275515441966476750422865623012506686836050591933025940027195025269539540970156240264101660652667932428162370624916490518462675560031775393479522046739038463483945901233761171384386859213837633328510780848n,
    ],
  ] as const;
  for (const [[base, exp, mod], expected] of cases) {
    assertEquals(modExp(base, exp, mod), expected);
  }
});

Deno.test("mod", () => {
  const cases = [
    [
      [
        1008332489173252079790276533869085736128020742729488687067968837992191762231245949019070513434824949460059601913292728043539790017288912049699472070409622758179283812335257279309961295765141101877383864306664277890823510624810181883338695147555972869831516480723788309358638457418794342994539152816595498948129460516685889444616886137360421460934696387887311049818016120785245473228528253970555208581595842872549670352800250579998946479421207246238271871977266575082809562020718847311387611701531211727041935498800390651462718278533394779354353694127085962654372286927870965447512362139798940741155602533871752396418609059291713820393140758045176769079860176701514558694251907520830213920300428813093512212211217114703647343882203602930249844197791926632015906843432949461182879035852820303618247355866487386625947466068679421488019441965379714392573860897422488575087784457348470638235037980911095934048841530447694105556246290522482925128372912882978871452107757473713606183334305903286999099882662597691978989286899862167794472170973603739092994684867871958777521235361009409981882783215561700014162859267638215017792006981414799367539889439193037963638160894524247287532596883638794549786654974913647511887614882497484446766545918n,
        277853713n,
      ],
      261166829n,
    ],
  ] as const;
  for (const [[a, b], expected] of cases) {
    assertEquals(mod(a, b), expected);
  }
});

Deno.test("bigIntFromBuffer", () => {
  const cases = {
    little: {
      signed: [
        [
          new Uint8Array([237, 135, 193, 43]),
          734103533n,
        ],
      ],
      unsigned: [
        [
          new Uint8Array([219, 215, 124, 150]),
          2524764123n,
        ],
      ],
    },
    big: {
      signed: [
        [
          new Uint8Array([157, 16, 216, 187]),
          -1659840325n,
        ],
      ],
      unsigned: [
        [
          new Uint8Array([46, 141, 36, 188]),
          781001916n,
        ],
      ],
    },
  } as const;
  for (const [buffer, value] of cases.little.signed) {
    assertEquals(bigIntFromBuffer(buffer, true, true), value);
  }
  for (const [buffer, value] of cases.little.unsigned) {
    assertEquals(bigIntFromBuffer(buffer, true, false), value);
  }
  for (const [buffer, value] of cases.big.signed) {
    assertEquals(bigIntFromBuffer(buffer, false, true), value);
  }
  for (const [buffer, value] of cases.big.unsigned) {
    assertEquals(bigIntFromBuffer(buffer, false, false), value);
  }
});

Deno.test("getRandomBigInt", async (t) => {
  const iterations = 10_000;
  const byteLengths = [3, 4, 8, 16, 32, 64];

  await t.step("signed", () => {
    for (let i = 0; i < iterations; i++) {
      for (const byteLength of byteLengths) {
        const bigInt = getRandomBigInt(byteLength, true, true);
        assert(Math.ceil(bigInt.toString(2).length / 8) <= byteLength);
      }
    }
  });

  await t.step("unsigned", () => {
    for (let i = 0; i < iterations; i++) {
      for (const byteLength of byteLengths) {
        const bigInt = getRandomBigInt(byteLength, true, false);
        assert(bigInt >= 0);
        assert(Math.ceil(bigInt.toString(2).length / 8) <= byteLength);
      }
    }
  });
});

Deno.test("getRandomId", () => {
  const iterations = 10_000;

  for (let i = 0; i < iterations; i++) {
    const bigint = getRandomId();
    assert(Math.ceil(bigint.toString(2).length / 8) <= 8);
  }
});
