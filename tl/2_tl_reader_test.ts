/**
 * MTKruto - Cross-runtime JavaScript library for building Telegram clients
 * Copyright (C) 2023-2025 Roj <https://roj.im/>
 *
 * This file is part of MTKruto.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import { assertEquals } from "../0_deps.ts";
import { gzip } from "../1_utilities.ts";
import { AnyObject } from "./0_api.ts";
import { TLRawWriter } from "./0_tl_raw_writer.ts";
import { BOOL_FALSE, BOOL_TRUE, GZIP_PACKED, VECTOR } from "./0_utilities.ts";
import { TLReader } from "./2_tl_reader.ts";
import { TLWriter } from "./2_tl_writer.ts";

Deno.test("deserialize", async (t) => {
  // deno-fmt-ignore
  const buffer = new Uint8Array([
    0x1E, 0x24, 0x1A, 0xCC, 0x48, 0x0E, 0x00, 0x00, 0xE7, 0x5F,
    0x6B, 0x64, 0x9F, 0x6C, 0x6B, 0x64, 0xB5, 0x75, 0x72, 0x99,
    0x02, 0x00, 0x00, 0x00, 0x15, 0xC4, 0xB5, 0x1C, 0x09, 0x00,
    0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18, 0x04, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x0E, 0x32, 0x30, 0x37, 0x2E, 0x31,
    0x35, 0x34, 0x2E, 0x32, 0x34, 0x31, 0x2E, 0x37, 0x33, 0x00,
    0xCF, 0x38, 0x00, 0x00, 0x11, 0xDD, 0xFD, 0xDA, 0x25, 0x4C,
    0x78, 0xD9, 0xFA, 0x20, 0x2A, 0xC5, 0x36, 0x07, 0x9E, 0x88,
    0xB8, 0x08, 0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18, 0x10, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x31, 0x34, 0x39,
    0x2E, 0x31, 0x35, 0x34, 0x2E, 0x31, 0x37, 0x35, 0x2E, 0x31,
    0x30, 0x00, 0x50, 0x00, 0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18,
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x32,
    0x30, 0x30, 0x31, 0x3A, 0x30, 0x62, 0x32, 0x38, 0x3A, 0x66,
    0x32, 0x33, 0x64, 0x3A, 0x66, 0x30, 0x30, 0x31, 0x3A, 0x30,
    0x30, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x30, 0x30, 0x3A, 0x30,
    0x30, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x30, 0x65, 0xBB, 0x01,
    0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18, 0x10, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x0E, 0x31, 0x34, 0x39, 0x2E, 0x31,
    0x35, 0x34, 0x2E, 0x31, 0x36, 0x37, 0x2E, 0x34, 0x30, 0x00,
    0xBB, 0x01, 0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18, 0x04, 0x04,
    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x32, 0x30, 0x37,
    0x2E, 0x31, 0x35, 0x34, 0x2E, 0x32, 0x34, 0x31, 0x2E, 0x37,
    0x33, 0x00, 0xCF, 0x38, 0x00, 0x00, 0x11, 0xDD, 0xFD, 0xDA,
    0x25, 0x4C, 0x78, 0xD9, 0xFA, 0x20, 0x2A, 0xC5, 0x36, 0x07,
    0x9E, 0x88, 0xB8, 0x08, 0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18,
    0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x27, 0x32,
    0x30, 0x30, 0x31, 0x3A, 0x30, 0x36, 0x37, 0x63, 0x3A, 0x30,
    0x34, 0x65, 0x38, 0x3A, 0x66, 0x30, 0x30, 0x32, 0x3A, 0x30,
    0x30, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x30, 0x30, 0x3A, 0x30,
    0x30, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x30, 0x65, 0xBB, 0x01,
    0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18, 0x10, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x0F, 0x31, 0x34, 0x39, 0x2E, 0x31,
    0x35, 0x34, 0x2E, 0x31, 0x37, 0x35, 0x2E, 0x31, 0x31, 0x37,
    0xBB, 0x01, 0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18, 0x04, 0x04,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x32, 0x30, 0x37,
    0x2E, 0x31, 0x35, 0x34, 0x2E, 0x32, 0x34, 0x31, 0x2E, 0x37,
    0x33, 0x00, 0xCF, 0x38, 0x00, 0x00, 0x11, 0xDD, 0xFD, 0xDA,
    0x25, 0x4C, 0x78, 0xD9, 0xFA, 0x20, 0x2A, 0xC5, 0x36, 0x07,
    0x9E, 0x88, 0xB8, 0x08, 0x00, 0x00, 0x0D, 0xA1, 0xB7, 0x18,
    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x27, 0x32,
    0x30, 0x30, 0x31, 0x3A, 0x30, 0x62, 0x32, 0x38, 0x3A, 0x66,
    0x32, 0x33, 0x64, 0x3A, 0x66, 0x30, 0x30, 0x33, 0x3A, 0x30,
    0x30, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x30, 0x30, 0x3A, 0x30,
    0x30, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x30, 0x65, 0xBB, 0x01,
    0x00, 0x00, 0x0E, 0x74, 0x61, 0x70, 0x76, 0x33, 0x2E, 0x73,
    0x74, 0x65, 0x6C, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x32, 0x00,
    0x00, 0x00, 0xF4, 0x01, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
    0x50, 0x34, 0x03, 0x00, 0x88, 0x13, 0x00, 0x00, 0x30, 0x75,
    0x00, 0x00, 0xE0, 0x93, 0x04, 0x00, 0x30, 0x75, 0x00, 0x00,
    0xDC, 0x05, 0x00, 0x00, 0x60, 0xEA, 0x00, 0x00, 0x02, 0x00,
    0x00, 0x00, 0x84, 0x03, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F,
    0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xEA, 0x24, 0x00, 0xC8, 0x00,
    0x00, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x20, 0x4E, 0x00, 0x00,
    0x90, 0x5F, 0x01, 0x00, 0x30, 0x75, 0x00, 0x00, 0x10, 0x27,
    0x00, 0x00, 0x0D, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F,
    0x2F, 0x74, 0x2E, 0x6D, 0x65, 0x2F, 0x00, 0x00, 0x0A, 0x63,
    0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x62, 0x6F, 0x74, 0x00,
    0x0D, 0x66, 0x6F, 0x75, 0x72, 0x73, 0x71, 0x75, 0x61, 0x72,
    0x65, 0x62, 0x6F, 0x74, 0x00, 0x00, 0x08, 0x69, 0x6D, 0x61,
    0x67, 0x65, 0x62, 0x6F, 0x74, 0x00, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00
  ]);
  const reader = new TLReader(buffer);
  const config = await reader.deserialize("config") as AnyObject;

  assertEquals(new TLWriter().serialize(config).buffer, buffer);
  assertEquals(config._, "config");

  await t.step("X", async () => {
    const reader = new TLReader(buffer);
    const config = await reader.deserialize("X") as AnyObject;

    assertEquals(new TLWriter().serialize(config).buffer, buffer);
    assertEquals(config._, "config");
  });

  await t.step("gzip", async () => {
    const writer = new TLRawWriter();
    writer.writeInt32(GZIP_PACKED, false);
    writer.writeBytes(await gzip(buffer));

    const reader = new TLReader(writer.buffer);
    const config = await reader.deserialize("config") as AnyObject;

    assertEquals(new TLWriter().serialize(config).buffer, buffer);
    assertEquals(config._, "config");
  });

  await t.step("gzip X", async () => {
    const writer = new TLRawWriter();
    writer.writeInt32(GZIP_PACKED, false);
    writer.writeBytes(await gzip(buffer));

    const reader = new TLReader(writer.buffer);
    const config = await reader.deserialize("X") as AnyObject;

    assertEquals(new TLWriter().serialize(config).buffer, buffer);
    assertEquals(config._, "config");
  });
});

Deno.test("optional double", async () => {
  // deno-fmt-ignore
  const buffer = new Uint8Array([
    0x94, 0xb0, 0x33, 0xde,
    0x01, 0x00, 0x00, 0x00,
    0x01, 0x75, 0x00, 0x00,
    0x20, 0x03, 0x00, 0x00,
    0x20, 0x03, 0x00, 0x00,
    0x88, 0xfc, 0x03, 0x00,
    0xe5, 0x46, 0x91, 0xb5,
    0x86, 0x72, 0x02, 0x40
  ]);

  const expected = {
    _: "videoSize",
    type: "u",
    w: 800,
    h: 800,
    size: 261256,
    video_start_ts: 2.305921,
    // deno-lint-ignore no-explicit-any
  } as any;

  const reader = new TLReader(buffer);
  const actual = await reader.deserialize("videoSize");

  assertEquals(actual, expected);
});

Deno.test("primitives", async (t) => {
  const writer = new TLRawWriter();

  const bytes = new Uint8Array(16);
  writer.writeBytes(bytes);

  const bytes2 = new Uint8Array(1024 * 1024);
  writer.writeBytes(bytes2);

  const int128 = -17014118346046923173168730305728n;
  writer.writeInt128(int128);

  const int256 = 115792089237316195423570985008687907853269984665640564039457584007913129676n;
  writer.writeInt256(int256);

  const double = 1.0205;
  writer.writeDouble(double);

  const long = -92233720368547708n;
  writer.writeInt64(long);

  const int = 777000;
  writer.writeInt32(int);

  const boolTrue = true;
  writer.writeInt32(BOOL_TRUE, false);

  const boolFalse = false;
  writer.writeInt32(BOOL_FALSE, false);

  const string = "MTKruto";
  writer.writeString(string);

  const string2 = string.repeat(256);
  writer.writeString(string2);

  const reader = new TLReader(writer.buffer);

  await t.step("bytes", async () => {
    let deserialized = await reader.deserialize("bytes");
    assertEquals(deserialized, bytes);
    deserialized = await reader.deserialize("bytes");
    assertEquals(deserialized, bytes2);
  });

  await t.step("int128", async () => {
    const deserialized = await reader.deserialize("int128");
    assertEquals(deserialized, int128);
  });

  await t.step("int256", async () => {
    const deserialized = await reader.deserialize("int256");
    assertEquals(deserialized, int256);
  });

  await t.step("double", async () => {
    const deserialized = await reader.deserialize("double");
    assertEquals(deserialized, double);
  });

  await t.step("long", async () => {
    const deserialized = await reader.deserialize("long");
    assertEquals(deserialized, long);
  });

  await t.step("true", async () => {
    const lengthBefore = reader.buffer.length;
    for (let i = 0; i < 10; ++i) {
      const deserialized = await reader.deserialize("true");
      assertEquals(deserialized, true);
    }
    assertEquals(reader.buffer.length, lengthBefore);
  });

  await t.step("int", async () => {
    const deserialized = await reader.deserialize("int");
    assertEquals(deserialized, int);
  });

  await t.step("Bool", async () => {
    let deserialized = await reader.deserialize("Bool");
    assertEquals(deserialized, boolTrue);
    deserialized = await reader.deserialize("Bool");
    assertEquals(deserialized, boolFalse);
  });

  await t.step("string", async () => {
    let deserialized = await reader.deserialize("string");
    assertEquals(deserialized, string);
    deserialized = await reader.deserialize("string");
    assertEquals(deserialized, string2);
  });
});

Deno.test("primitive vectors", async () => {
  const writer = new TLRawWriter();
  writer.writeInt32(VECTOR, false);
  const expected = new Array(1024).fill(null).map((_, i) => i * Math.random());
  writer.writeInt32(expected.length);
  for (const item of expected) {
    writer.writeDouble(item);
  }
  const deserialized = await new TLReader(writer.buffer).deserialize("Vector<double>");
  assertEquals(deserialized, expected);
});
